//
//  main.cpp
//  76 Min Window
//
//  Created by 刘亚东 on 2024/2/29.
//
// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

// 注意：
// 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
// 如果 s 中存在这样的子串，我们保证它是唯一的答案。

#include <iostream>

using std::vector;
using std::unordered_map;
using std::string;

///
/// 再次重申滑动窗口的思想：
/// 用 i，j 表示滑动窗口的左右边界，通过改变 i，j 来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走
/// 当这个窗口包含的元素满足条件，即包含字符串 T 的所有元素，记录下这个滑动窗口的长度 j - i + 1，这些长度的最小值就是要求的结果
///
/// 第一步：
/// 不断增加 j 使滑动窗口增大，直到窗口包含了 T 的所有元素
///
/// 第二步：
/// 不断增加 i 使滑动窗口缩小，因为是要求最小子串，所以将不必要的元素排出在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再缩小了
/// 再缩小就不满足条件了，记录此时滑动窗口的长度，并保存最小值
///
/// 第三步：
/// 让 i 再增加一个位置， 这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到 j 超出了字符串 s 的范围。
///
/// 如何判断滑动窗口包含了 T 的所有元素？
/// 用一个字典 need 来表示当前滑动窗口中需要的各元素数量，一开始滑动窗口为空，用 T 中各元素来初始化 need，当滑动窗口扩展或收缩的时候，维护这个 need 字典，
/// 例如当滑动窗口包含了某个元素，need 中这个元素的数量减 1，代表所需元素减少了 1 个；当滑动窗口移除某个元素，就让 need 中这个元素的数量加1。
///
/// 注：need 始终维护当前滑动窗口下，我们还需要的元素数量，我们在改变 i，j 时，需同步维护 need。
///
/// 值得注意的是，只要某个元素包含在滑动窗口中，我们就会在need中存储这个元素的数量，如果某个元素存储的是负数代表这个元素是多余的。
/// 比如当need等于{'A':-2,'C':1}时，表示当前滑动窗口中，我们有2个A是多余的，同时还需要1个C。
/// 这么做的目的就是为了步骤二中，排除不必要的元素，数量为负的就是不必要的元素，而数量为0表示刚刚好。
///
/// 那么如何判断滑动窗口包含了T的所有元素？结论就是当need中所有元素的数量都小于等于0时，表示当前滑动窗口不再需要任何元素。
///
///
/// 优化：
/// 如果每次判断滑动窗口是否包含了T的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费O(k)的时间复杂度，k代表字典长度，最坏情况下，k可能等于len(S)。
/// 其实这个是可以避免的，我们可以维护一个额外的变量needCnt来记录所需元素的总数量，当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时needCnt也要减少1，这样我们通过needCnt就可以知道是否满足条件，而无需遍历字典了。
/// 前面也提到过，need记录了遍历到的所有元素，而只有need[c]>0大于0时，代表c就是所需元素
///

class Solution {
public:
    static string minWindow(string s, string t) {
        unordered_map<char, int>need;
        for (auto c: t) need[c]++; // 初始化 need 字典
        
        int needCnt = static_cast<int>(t.size());
        
        string res;
        for (int i = 0, j = 0; j < s.size(); j++) {
            if (need[s[j]] > 0) { // need值可能是负数，不能少了"> 0"！
                needCnt--;
            }
            
            need[s[j]]--;
            
            if (needCnt == 0) {
                while (need[s[i]] < 0) {
                    need[s[i++]]++;
                }
                
                int len = j - i + 1;
                if (res.empty() || res.size() > len) {
                    res = s.substr(i, len);
                }
                
                need[s[i++]]++;
                needCnt++;
            }
        }
        return res;
    }
};

int main(int argc, const char * argv[]) {
    // insert code here...
    string s = "a";
    string t = "aa";
    std::cout << Solution::minWindow(s, t) << std::endl;
    return 0;
}
